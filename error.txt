#include <linux/module.h>
#include <linux/init.h>
#include <linux/mod_devicetable.h>
#include <linux/platform_device.h>
#include <linux/of_device.h>
#include <linux/gpio/consumer.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/jiffies.h>

/* Meta Information */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("fernando-oechsler");
MODULE_DESCRIPTION("Teste com LED piscando via thread");

/* Funções */
static int dt_probe(struct platform_device *pdev);
static void dt_remove(struct platform_device *pdev);

/* Match com o device tree */
static const struct of_device_id my_driver_ids[] = {
	{ .compatible = "keyboard,msa620" },
	{ }
};
MODULE_DEVICE_TABLE(of, my_driver_ids);

/* Platform driver struct */
static struct platform_driver my_driver = {
	.probe = dt_probe,
	.remove = dt_remove,
	.driver = {
		.name = "my_device_driver",
		.of_match_table = my_driver_ids,
	},
};

/* GPIO e thread */
static struct gpio_desc *my_led = NULL;
static struct task_struct *blink_thread = NULL;
static bool running = true;

/* Thread Function */
static int blink_fn(void *data) {
	bool led_on = false;
	unsigned long last_jiffies = jiffies;

	while (!kthread_should_stop()) {
		if (time_after(jiffies, last_jiffies + msecs_to_jiffies(500))) {
			led_on = !led_on;
			gpiod_set_value(my_led, led_on);
			last_jiffies = jiffies;
		}
		schedule(); // Libera CPU até o próximo tick
	}

	/* Ao sair, garante que LED desliga */
	gpiod_set_value(my_led, 0);
	return 0;
}

/* Probe */
static int dt_probe(struct platform_device *pdev) {
	struct device *dev = &pdev->dev;
	int ret;

	printk("dt_gpio - Probe chamado\n");

	my_led = gpiod_get(dev, "ledtec", GPIOD_OUT_LOW);
	if (IS_ERR(my_led)) {
		printk("dt_gpio - Erro ao obter LED\n");
		return PTR_ERR(my_led);
	}

	blink_thread = kthread_run(blink_fn, NULL, "blink_thread");
	if (IS_ERR(blink_thread)) {
		printk("dt_gpio - Erro ao criar thread\n");
		ret = PTR_ERR(blink_thread);
		gpiod_put(my_led);
		return ret;
	}

	printk("dt_gpio - Probe finalizado com sucesso\n");
	return 0;
}

/* Remove */
static void dt_remove(struct platform_device *pdev) {
	printk("dt_gpio - Remove chamado\n");

	if (blink_thread) {
		kthread_stop(blink_thread);
		blink_thread = NULL;
	}

	gpiod_set_value(my_led, 0);
	gpiod_put(my_led);
}

/* Init */
static int __init my_init(void) {
	printk("dt_gpio - Driver carregando...\n");
	return platform_driver_register(&my_driver);
}

/* Exit */
static void __exit my_exit(void) {
	printk("dt_gpio - Driver descarregando...\n");
	platform_driver_unregister(&my_driver);
}

module_init(my_init);
module_exit(my_exit);

#include <linux/module.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/gpio/consumer.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/input.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Fernando Oechsler");
MODULE_DESCRIPTION("Driver teclado msa620 com thread e input");
MODULE_VERSION("1.0");

#define NUM_ROWS 6
#define NUM_COLS 5

static struct gpio_descs *row_gpios;
static struct gpio_descs *col_gpios;
static struct gpio_desc *ledtec_gpio;

static struct input_dev *input_dev;
static struct task_struct *keyboard_task;

/* Mapa de teclas */
static const int key_map[NUM_ROWS][NUM_COLS] = {
    {KEY_F5, KEY_F4, KEY_F3, KEY_F2, KEY_F1},
    {KEY_UP, -1, KEY_3, KEY_2, KEY_1},
    {KEY_RIGHT, KEY_LEFT, -1, -1, -1},
    {KEY_DOWN, -1, KEY_6, KEY_5, KEY_4},
    {KEY_ENTER, KEY_ESC, KEY_9, KEY_8, KEY_7},
    {-1, -1 , -1, KEY_0, -1}
};

/* Thread de varredura */
static int keyboard_thread_fn(void *data) {
    bool led_state = false;
    unsigned long led_jiffies = jiffies;
    int col, row;

    while (!kthread_should_stop()) {
        /* LED blink a cada 500ms */
        if (time_after(jiffies, led_jiffies + msecs_to_jiffies(500))) {
            led_state = !led_state;
            gpiod_set_value(ledtec_gpio, led_state);
            led_jiffies = jiffies;
        }

        for (col = 0; col < NUM_COLS; col++) {
            /* Ativa coluna (LOW) */
            gpiod_set_value(col_gpios->desc[col], 0);

            for (row = 0; row < NUM_ROWS; row++) {
                int val = gpiod_get_value(row_gpios->desc[row]);
                int keycode = key_map[row][col];

                if (keycode == -1)
                    continue;

                if (!val) {
                    input_report_key(input_dev, keycode, 1);
                    input_sync(input_dev);
                } else {
                    input_report_key(input_dev, keycode, 0);
                    input_sync(input_dev);
                }
            }

            /* Desativa coluna (HIGH) */
            gpiod_set_value(col_gpios->desc[col], 1);
        }
        cpu_relax(); /* Mantém o kernel respirando, sem travar */
    }

    return 0;
}

/* Probe */
static int msa620_probe(struct platform_device *pdev) {
    int ret, i;

    row_gpios = gpiod_get_array(&pdev->dev, "row", GPIOD_IN);
    if (IS_ERR(row_gpios))
        return PTR_ERR(row_gpios);

    col_gpios = gpiod_get_array(&pdev->dev, "col", GPIOD_OUT_HIGH);
    if (IS_ERR(col_gpios)) {
        ret = PTR_ERR(col_gpios);
        goto err_rows;
    }

    ledtec_gpio = gpiod_get(&pdev->dev, "ledtec", GPIOD_OUT_LOW);
    if (IS_ERR(ledtec_gpio)) {
        ret = PTR_ERR(ledtec_gpio);
        goto err_cols;
    }

    input_dev = input_allocate_device();
    if (!input_dev) {
        ret = -ENOMEM;
        goto err_led;
    }

    input_dev->name = "msa620-keyboard";
    input_dev->phys = "gpio/msa620";
    input_dev->id.bustype = BUS_HOST;
    input_dev->evbit[0] = BIT_MASK(EV_KEY);

    /* Registra todas as teclas do mapa */
    for (i = 0; i < NUM_ROWS; i++) {
        int j;
        for (j = 0; j < NUM_COLS; j++) {
            if (key_map[i][j] != -1)
                set_bit(key_map[i][j], input_dev->keybit);
        }
    }

    ret = input_register_device(input_dev);
    if (ret)
        goto err_input;

    keyboard_task = kthread_run(keyboard_thread_fn, NULL, "msa620_kb_thread");
    if (IS_ERR(keyboard_task)) {
        ret = PTR_ERR(keyboard_task);
        goto err_input_reg;
    }

    dev_info(&pdev->dev, "msa620 keyboard driver loaded\n");
    return 0;

err_input_reg:
    input_unregister_device(input_dev);
    input_dev = NULL;
err_input:
    input_free_device(input_dev);
err_led:
    gpiod_put(ledtec_gpio);
err_cols:
    gpiod_put_array(col_gpios);
err_rows:
    gpiod_put_array(row_gpios);
    return ret;
}

/* Remove */
static void msa620_remove(struct platform_device *pdev) {
    kthread_stop(keyboard_task);
    input_unregister_device(input_dev);
    gpiod_put(ledtec_gpio);
    gpiod_put_array(col_gpios);
    gpiod_put_array(row_gpios);
    dev_info(&pdev->dev, "msa620 keyboard driver unloaded\n");
}

/* Match */
static const struct of_device_id msa620_of_match[] = {
    { .compatible = "keyboard,msa620" },
    { }
};
MODULE_DEVICE_TABLE(of, msa620_of_match);

/* Platform driver */
static struct platform_driver msa620_driver = {
    .probe = msa620_probe,
    .remove = msa620_remove,
    .driver = {
        .name = "msa620_keyboard",
        .of_match_table = msa620_of_match,
    },
};

module_platform_driver(msa620_driver);
